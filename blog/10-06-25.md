I've ended up taking a detour before the GPU article given a problem with matrices I wanted to dive into a bit, matrix rotations.
For right now, specifically square (n x n size) matrices (because they seem easier at first glance?).

Rotating matrices involves transposing them (flipping them across the diagonal, which goes from [0][0], [1][1] ... [n][n], or visually the top left to bottom right) and then applying another operation depending on what we want. To rotate counter-clockwise we reverse the columns, and to rotate clockwise we reverse the rows. To get the last possible variation of a rotation problem (rotated 180 degrees) we either repeat the same direction one more time, or from the prior transposed matrix we would flip across what is called the anti-diagonal (visually the top right to bottom left, or programatically across [n][0], [n-1][1] ... [0][n]).

While reversing rows and columns is simple enough (a simple two pointer from each bound going inwards, looped n times for each row/column), the flipping across the diagonal is a bit more uninituitive. The diagonal is in fact the only thing we don't touch, as we want to swap everything outside of it. However, when realizing the relationship of what we are swapping, it becomes a substantially more approachable problem; we every element is swaped with the swapped value between row and column ([0][1] with [1][0], [2][3] with [3][2], etc). Going further, because of the fact that we know what value we need to swap with just by having a value, we only need to loop over one side of the diagonal. This is the tricky part, but when you visualize a matrix with its indexing values:
```
[0,0][1,0][2,0][3,0]
[0,1][1,1][2,1][3,1]
[0,2][1,2][2,2][3,2]
[0,3][1,3][2,3][3,3]
```
then trim it to what we actually need to look at:
```
[0,1]
[0,2][1,2]
[0,3][1,3][2,3]
```
the pattern starts to emerge. A for loop with an increasing bound
omitting our diagonal, similar to how we trim our matrix:
```
for column in range(n):
    for row in range(column, n):
column = 0 :
row = 1
row = 2
row = 3
column = 1:
row = 2
row = 3
column = 2:
row = 3
```
now we simply swap during each value, and replacing column and row with i and j as they do not stricty represent those values how we are using them:
```
a = m[i][j]
b = m[j][i]
m[i][j] = b
m[j][i] = a
```
(or employ a classic XOR trick if a compiler doesn't optimize swaps at all for some reason)
```
m[i][j] = m[i][j] ^ m[j][i]
m[j][i] = m[i][j] ^ m[j][i]
m[i][j] = m[i][j] ^ m[j][i]
```
and we get our transposed result.
That's not too bad, now how about the anti-transpose? We no longer have this luxury of equal values:
```
[0,0][1,0][2,0]
[0,1][1,1]       
[0,2]
               [3,1]
          [2,2][3,2]
     [1,3][2,3][3,3]
```
Lets take some matching matrix coordinate pairs, keeping in mind n = 4:
```
[1,0] <-> [3,2]
[0,1] <-> [2,3]

[2,0] <-> [3,1]
[0,2] <-> [1,3]
```
if we extrapolate using i/j and n:
[i,j] <-> [n-1 -j, n-1 -i]
Expanding this matrix to n = 5 for the sake of showing a pattern:
```
[0,0][1,0][2,0][3,0]
[0,1][1,1][2,1]       
[0,2][1,2]
[0,3]
                    [4,1]
               [3,2][4,2]
          [2,3][3,3][4,3]
     [1,4][2,4][3,4][4,4]

[1,0] <-> [4,3]
[0,1] <-> [3,4]

[2,0] <-> [4,2]
[0,2] <-> [2,4]

[2,1] <-> [3,2]
[1,2] <-> [2,3]

[3,0] <-> [4,1]
[0,3] <-> [1,4]
```

As you can see for n = 5, we the universal rules is still [i,j] <-> [n-1-j, n-1-i]
Lets do one more, n = 6,

```
[0,0][1,0][2,0][3,0][4,0]
[0,1][1,1][2,1][3,1]
[0,2][1,2][2,2]
[0,3][1,3]
[0,4]
                         [5,1]
                    [4,2][5,2]
               [3,3][4,3][5,3]
          [2,4][3,4][4,4][5,4]
     [1,5][2,5][3,5][4,5][5,5]
     
[1,0] <-> [5,4]
[0,1] <-> [4,5]

[2,0] <-> [5,3]
[0,2] <-> [3,5]

[2,1] <-> [4,3]
[1,2] <-> [3,4]

[3,0] <-> [4,1]
[0,3] <-> [1,4]
...
```
the pattern continues, so it's fairly safe to assume this is correct.
While this is likely a very basic property, writing this out has helped me solidify it in my mind.
This article also served as something of a formatting test for how certain things will be displayed.
